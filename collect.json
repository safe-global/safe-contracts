{"original": "https://prover.certora.com/jobStatus/11775/eb0eb79944e448c7bec15d979c5eadfa?anonymousKey=d2774c9d36a4afed9edb580bcaa7a7e21dcea606", "mutants": [{"gambit_mutant": {"filename": "gambit_out/mutants/1/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/1", "id": "1", "diff": "--- original\n+++ mutant\n@@ -103,7 +103,8 @@\n     ) external {\n         // setupOwners checks if the Threshold is already set, therefore preventing that this method is called twice\n         setupOwners(_owners, _threshold);\n-        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n+        /// IfStatementMutation(`fallbackHandler != address(0)` |==> `false`) of: `if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);`\n+        if (false) internalSetFallbackHandler(fallbackHandler);\n         // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n         setupModules(to, data);\n \n", "description": "IfStatementMutation"}, "link": "https://prover.certora.com/jobStatus/11775/1fc80fb095034a29b5140889ef70190f?anonymousKey=f13304d4b85fb794e46bf657f741a7a767dfcb32", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_700/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/2/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/2", "id": "2", "diff": "--- original\n+++ mutant\n@@ -107,7 +107,8 @@\n         // As setupOwners can only be called if the contract has not been initialized we don't need a check for setupModules\n         setupModules(to, data);\n \n-        if (payment > 0) {\n+        /// SwapArgumentsOperatorMutation(`payment > 0` |==> `0 > payment`) of: `if (payment > 0) {`\n+        if (0 > payment) {\n             // To avoid running into issues with EIP-170 we reuse the handlePayment function (to avoid adjusting code of that has been verified we do not adjust the method itself)\n             // baseGas = 0, gasPrice = 1 and gas = payment => amount = (payment + 0) * 1 = payment\n             handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n", "description": "SwapArgumentsOperatorMutation"}, "link": "https://prover.certora.com/jobStatus/11775/c137c9377a4948f08ceb901fd0d0203c?anonymousKey=d62c3007d8dfeea8450f2f68837ac3eb60c1add2", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_872/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/3/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/3", "id": "3", "diff": "--- original\n+++ mutant\n@@ -191,7 +191,8 @@\n \n         // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\n         // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\n-        require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");\n+        /// BinaryOpMutation(`/` |==> `*`) of: `require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, \"GS010\");`\n+        require(gasleft() >= ((safeTxGas * 64)*63).max(safeTxGas + 2500) + 500, \"GS010\");\n         // Use scope here to limit variable lifetime and prevent `stack too deep` errors\n         {\n             uint256 gasUsed = gasleft();\n", "description": "BinaryOpMutation"}, "link": "https://prover.certora.com/jobStatus/11775/236922ff2b8546f3b7ae6673b37c6079?anonymousKey=0b5de91cc0683be63521463fbad500a4c8b68a07", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_905/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/4/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/4", "id": "4", "diff": "--- original\n+++ mutant\n@@ -197,7 +197,8 @@\n             uint256 gasUsed = gasleft();\n             // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)\n             // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas\n-            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);\n+            /// AssignmentMutation(`execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas)` |==> `true`) of: `success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);`\n+            success = true;\n             gasUsed = gasUsed.sub(gasleft());\n             // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\n             // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\n", "description": "AssignmentMutation"}, "link": "https://prover.certora.com/jobStatus/11775/5237c45457974ab8b590b40493d580c7?anonymousKey=53de04c38e76613c2687e84d43f2bb861c0bef9f", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_436/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/5/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/5", "id": "5", "diff": "--- original\n+++ mutant\n@@ -207,7 +207,8 @@\n             if (gasPrice > 0) {\n                 payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);\n             }\n-            if (success) emit ExecutionSuccess(txHash, payment);\n+            /// IfStatementMutation(`success` |==> `true`) of: `if (success) emit ExecutionSuccess(txHash, payment);`\n+            if (true) emit ExecutionSuccess(txHash, payment);\n             else emit ExecutionFailure(txHash, payment);\n         }\n         {\n", "description": "IfStatementMutation"}, "link": "https://prover.certora.com/jobStatus/11775/c7736d94ccd94e9fb77492a3906eb091?anonymousKey=3c3f90227e467d92368a85118cbca9cb0eba43ee", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_871/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/6/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/6", "id": "6", "diff": "--- original\n+++ mutant\n@@ -241,7 +241,8 @@\n             require(refundSuccess, \"GS011\");\n         } else {\n             payment = gasUsed.add(baseGas).mul(gasPrice);\n-            require(transferToken(gasToken, receiver, payment), \"GS012\");\n+            /// DeleteExpressionMutation(`require(transferToken(gasToken, receiver, payment), \"GS012\")` |==> `assert(true)`) of: `require(transferToken(gasToken, receiver, payment), \"GS012\");`\n+            assert(true);\n         }\n     }\n \n", "description": "DeleteExpressionMutation"}, "link": "https://prover.certora.com/jobStatus/11775/d0f616f70ebf441eb376899723e31edd?anonymousKey=c9b7bc323aca4eb4f663d4c9c2609405f804ffed", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_320/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/7/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/7", "id": "7", "diff": "--- original\n+++ mutant\n@@ -241,7 +241,8 @@\n             require(refundSuccess, \"GS011\");\n         } else {\n             payment = gasUsed.add(baseGas).mul(gasPrice);\n-            require(transferToken(gasToken, receiver, payment), \"GS012\");\n+            /// RequireMutation(`transferToken(gasToken, receiver, payment)` |==> `false`) of: `require(transferToken(gasToken, receiver, payment), \"GS012\");`\n+            require(false, \"GS012\");\n         }\n     }\n \n", "description": "RequireMutation"}, "link": "https://prover.certora.com/jobStatus/11775/356785ae90de4195adffb54e6be754bf?anonymousKey=24efcf31cc048591d9b6ddbaba12e8abec1b96eb", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_468/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/8/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/8", "id": "8", "diff": "--- original\n+++ mutant\n@@ -236,7 +236,8 @@\n         address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\n         if (gasToken == address(0)) {\n             // For native tokens, we will only adjust the gas price to not be higher than the actually used gas price\n-            payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\n+            /// SwapArgumentsOperatorMutation(`gasPrice < tx.gasprice` |==> `tx.gasprice < gasPrice`) of: `payment = gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice);`\n+            payment = gasUsed.add(baseGas).mul(tx.gasprice < gasPrice ? gasPrice : tx.gasprice);\n             (bool refundSuccess, ) = receiver.call{value: payment}(\"\");\n             require(refundSuccess, \"GS011\");\n         } else {\n", "description": "SwapArgumentsOperatorMutation"}, "link": "https://prover.certora.com/jobStatus/11775/20130a666899468c9fd8d1de8f55f72e?anonymousKey=13cb042db1594117ab0115bed3aee05cc04c03ef", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_697/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/9/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/9", "id": "9", "diff": "--- original\n+++ mutant\n@@ -256,7 +256,8 @@\n         // Load threshold to avoid multiple storage loads\n         uint256 _threshold = threshold;\n         // Check that a threshold is set\n-        require(_threshold > 0, \"GS001\");\n+        /// SwapArgumentsOperatorMutation(`_threshold > 0` |==> `0 > _threshold`) of: `require(_threshold > 0, \"GS001\");`\n+        require(0 > _threshold, \"GS001\");\n         checkNSignatures(msg.sender, dataHash, data, signatures, _threshold);\n     }\n \n", "description": "SwapArgumentsOperatorMutation"}, "link": "https://prover.certora.com/jobStatus/11775/5459908a7930440b90d575e1dcf24160?anonymousKey=5eddfe5e15d763fe160332932c7163a25a1b4dab", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_188/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/10/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/10", "id": "10", "diff": "--- original\n+++ mutant\n@@ -282,7 +282,8 @@\n         uint256 requiredSignatures\n     ) public view {\n         // Check that the provided signature data is not too short\n-        require(signatures.length >= requiredSignatures.mul(65), \"GS020\");\n+        /// RequireMutation(`signatures.length >= requiredSignatures.mul(65)` |==> `false`) of: `require(signatures.length >= requiredSignatures.mul(65), \"GS020\");`\n+        require(false, \"GS020\");\n         // There cannot be an owner with address 0.\n         address lastOwner = address(0);\n         address currentOwner;\n", "description": "RequireMutation"}, "link": "https://prover.certora.com/jobStatus/11775/bb39be26cead489f937a3c63b911e98d?anonymousKey=56d213fe7eb15cbc5611113e041b8026594dbca0", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_21_838/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/11/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/11", "id": "11", "diff": "--- original\n+++ mutant\n@@ -332,7 +332,8 @@\n             } else if (v > 30) {\n                 // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                 // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n-                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n+                /// BinaryOpMutation(`-` |==> `+`) of: `currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);`\n+                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v+4, r, s);\n             } else {\n                 // Default is the ecrecover flow with the provided data hash\n                 // Use ecrecover with the messageHash for EOA signatures\n", "description": "BinaryOpMutation"}, "link": "https://prover.certora.com/jobStatus/11775/784e4828854443a1b067a2d1f0fa713e?anonymousKey=dc754df265e35a966bebce7a00d359cc7315df56", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_28_767/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/12/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/12", "id": "12", "diff": "--- original\n+++ mutant\n@@ -328,7 +328,8 @@\n                 // When handling approved hashes the address of the approver is encoded into r\n                 currentOwner = address(uint160(uint256(r)));\n                 // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n-                require(executor == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");\n+                /// DeleteExpressionMutation(`require(executor == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\")` |==> `assert(true)`) of: `require(executor == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"GS025\");`\n+                assert(true);\n             } else if (v > 30) {\n                 // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\n                 // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n", "description": "DeleteExpressionMutation"}, "link": "https://prover.certora.com/jobStatus/11775/187e56fd01b44da3815effa336e0abe6?anonymousKey=456104f40dd0ab661703dd2e8efe763296e4e188", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_28_315/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/13/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/13", "id": "13", "diff": "--- original\n+++ mutant\n@@ -303,7 +303,8 @@\n                 require(uint256(s) >= requiredSignatures.mul(65), \"GS021\");\n \n                 // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n-                require(uint256(s).add(32) <= signatures.length, \"GS022\");\n+                /// RequireMutation(`uint256(s).add(32) <= signatures.length` |==> `true`) of: `require(uint256(s).add(32) <= signatures.length, \"GS022\");`\n+                require(true, \"GS022\");\n \n                 // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n                 uint256 contractSignatureLen;\n", "description": "RequireMutation"}, "link": "https://prover.certora.com/jobStatus/11775/64c62ab81886415e8a1794ba24edaeca?anonymousKey=28228ec1711951da12967d70225fbf9798da12d3", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_28_867/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/14/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/14", "id": "14", "diff": "--- original\n+++ mutant\n@@ -338,7 +338,8 @@\n                 // Use ecrecover with the messageHash for EOA signatures\n                 currentOwner = ecrecover(dataHash, v, r, s);\n             }\n-            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n+            /// SwapArgumentsOperatorMutation(`currentOwner > lastOwner` |==> `lastOwner > currentOwner`) of: `require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");`\n+            require(lastOwner > currentOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, \"GS026\");\n             lastOwner = currentOwner;\n         }\n     }\n", "description": "SwapArgumentsOperatorMutation"}, "link": "https://prover.certora.com/jobStatus/11775/770f84e9a4cf4cce938849536aeeba4f?anonymousKey=0cf1487cb385f136bf214281cc1d051e6ac9aa68", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_28_140/.certora_sources"}, {"gambit_mutant": {"filename": "gambit_out/mutants/15/certora/munged/Safe.sol", "original_filename": "certora/munged/Safe.sol", "directory": "gambit_out/mutants/15", "id": "15", "diff": "--- original\n+++ mutant\n@@ -350,7 +350,8 @@\n      * @param hashToApprove The hash to mark as approved for signatures that are verified by this contract.\n      */\n     function approveHash(bytes32 hashToApprove) external {\n-        require(owners[msg.sender] != address(0), \"GS030\");\n+        /// DeleteExpressionMutation(`require(owners[msg.sender] != address(0), \"GS030\")` |==> `assert(true)`) of: `require(owners[msg.sender] != address(0), \"GS030\");`\n+        assert(true);\n         approvedHashes[msg.sender][hashToApprove] = 1;\n         emit ApproveHash(hashToApprove, msg.sender);\n     }\n", "description": "DeleteExpressionMutation"}, "link": "https://prover.certora.com/jobStatus/11775/edb87aa349024166821b1aeb7f8c12af?anonymousKey=bbe582e6a2858a07e11eb4aebe3ae63238fc4b22", "success": true, "run_directory": ".certora_internal/23_09_01_11_14_28_699/.certora_sources"}]}